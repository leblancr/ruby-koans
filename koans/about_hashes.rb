require File.expand_path(File.dirname(__FILE__) + '/neo')

class AboutHashes < Neo::Koan
  def test_creating_hashes
    empty_hash = Hash.new
    assert_equal Hash, empty_hash.class
    assert_equal({}, empty_hash)
    assert_equal 0, empty_hash.size
  end

  def test_hash_literals
    hash = { :one => "uno", :two => "dos" }
    assert_equal 2, hash.size
  end

  def test_accessing_hashes
    hash = { :one => "uno", :two => "dos" }
    assert_equal "uno", hash[:one]
    assert_equal "dos", hash[:two]
    assert_equal nil, hash[:doesnt_exist]
  end

  def test_accessing_hashes_with_fetch
    hash = { :one => "uno" }
    assert_equal "uno", hash.fetch(:one)
    # ensuring that the exception is raised in the first place.
    assert_raise(KeyError) do
      hash.fetch(:doesnt_exist)
    end

    # THINK ABOUT IT:
    #
    # Why might you want to use #fetch instead of #[] when accessing hash keys?
  end

  def test_changing_hashes
    hash = { :one => "uno", :two => "dos" }
    hash[:one] = "eins"

    expected = { :one => __, :two => "dos" }
    assert_equal({ one: "eins", two: "dos" }, hash)

    # Bonus Question: Why was "expected" broken out into a variable
    # rather than used as a literal?
  end

  def test_hash_is_unordered
    hash1 = { :one => "uno", :two => "dos" }
    hash2 = { :two => "dos", :one => "uno" }

    assert_equal true, hash1 == hash2
  end

  def test_hash_keys
    hash = { :one => "uno", :two => "dos" }
    assert_equal 2, hash.keys.size
    assert_equal true, hash.keys.include?(:one)
    assert_equal true, hash.keys.include?(:two)
    assert_equal Array, hash.keys.class # keys are in an array
  end

  def test_hash_values
    hash = { :one => "uno", :two => "dos" }
    assert_equal 2, hash.values.size
    assert_equal true, hash.values.include?("uno")
    assert_equal true, hash.values.include?("dos")
    assert_equal Array, hash.values.class
  end

  def test_combining_hashes
    hash = { "jim" => 53, "amy" => 20, "dan" => 23 }
    new_hash = hash.merge({ "jim" => 54, "jenny" => 26 })

    assert_equal true, hash != new_hash

    expected = { "jim" => 54, "amy" => 20, "dan" => 23, "jenny" => 26 }
    assert_equal true, expected == new_hash
  end

  def test_default_value
    hash1 = Hash.new
    hash1[:one] = 1

    assert_equal 1, hash1[:one]
    assert_equal nil, hash1[:two]

    hash2 = Hash.new("dos") # default value for any key that is not set
    hash2[:one] = 1

    assert_equal 1, hash2[:one]
    assert_equal "dos", hash2[:two] # a key that is not set
  end

  def test_default_value_is_the_same_object
    hash = Hash.new([])  # Creates a hash with a default value of an empty array

    hash[:one] << "uno"  # Modifies the default array (now it contains "uno")
    hash[:two] << "dos"  # Modifies the same array (now it contains "uno" and "dos")

    assert_equal ["uno", "dos"], hash[:one]  # What is hash[:one] now? It should be ["uno", "dos"]
    assert_equal ["uno", "dos"], hash[:two]  # What is hash[:two] now? It should also be ["uno", "dos"]
    assert_equal ["uno", "dos"], hash[:three]  # What is hash[:three]? It will return the same array, ["uno", "dos"]

    assert_equal true, hash[:one].object_id == hash[:two].object_id  # Will this be true? Yes, because they reference the same array object.
  end

  def test_default_value_with_block
    # The block is invoked whenever a key that doesn't exist in the hash is accessed.
    # The block allows you to define a custom behavior for generating the default value for that key.
    hash = Hash.new {|hash, key| hash[key] = [] }  # Creates a hash with a default value generated by the block
    puts "hash1: #{hash}"
    # puts "hash.fetch: #{hash.fetch("test")}" # key not found: "test"
    puts "hash2[\"unknown_key\"]: #{hash["unknown_key"]}"

    # =: Directly sets a value for a key, overriding the default behavior.
    # <<: Modifies the existing value, and if the key does not exist,
    # it triggers the default block, which creates the value before modifying it.
    # For Arrays: The << operator appends the value to the array.
    # For Strings: It appends the string to the existing string.

    # :one does not exist in the hash, the default block is triggered,
    # Now that :one exists, << appends "uno" to the existing array ["default_value"],
    # resulting in ["default_value", "uno"].
    hash[:one] << "uno"  # Adds "uno" to the default array for :one
    puts "hash3: #{hash}"
    hash[:two] << "dos"  # Adds "dos" to the default array for :two
    puts "hash4: #{hash}"
#     hash[:one] << hash[:two]
#     puts "hash5: #{hash}"

    assert_equal ["uno"], hash[:one]  # What is hash[:one] now? It should be ["uno"]
    assert_equal ["dos"], hash[:two]  # What is hash[:two] now? It should be ["dos"]
    assert_equal [], hash[:three]  # What is hash[:three]? It should be an empty array, []
  end

  def test_default_value_attribute
    hash = Hash.new

    assert_equal nil, hash[:some_key]

    hash.default = 'peanut'

    assert_equal 'peanut', hash[:some_key]
  end
end
